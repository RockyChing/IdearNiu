#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <sys/types.h>
#include <wait.h>
#include <string.h>

#include <log_util.h>

/**
 * Signals are classic examples of asynchronous events
 * 1. Every signal has a default action, the default action for most signals is to terminate the process.
 * 2. When a process calls fork, the child inherits the parent’s signal dispositions. Here,
      since the child starts off with a copy of the parent’s memory image, the address of a
      signal-catching function has meaning in the child
 * 3. Most UNIX systems, however, do not queue signals unless they support the real-time extensions
      to POSIX.1. Instead, the UNIX kernel simply delivers the signal once.
 */



/**
 * The kill function uses the signal number of 0 for a special case.
 * POSIX.1 calls this value the null signal.
 *
 * #define SIGHUP		 1
 * Description: hangup
 * Default action: terminate
 *
 *
 * #define SIGINT		 2
 * Description: terminal interrupt character
 * Default action: terminate
 * generated when pressing the DELETE key on the terminal (or Control-C on many systems) normally
 *
 *
 * #define SIGQUIT		 3
 * Description: terminal quit character
 * Default action: terminate + core
 * This signal is generated by the terminal driver when we press the
 * terminal quit key (often Control-backslash)
 *
 * #define SIGILL		 4
 * Description: illegal instruction
 * Default action: terminate + core
 *
 *
 * #define SIGTRAP		 5
 * Description: hardware fault
 * Default action: terminate + core
 *
 *
 * #define SIGABRT		 6
 * Description: abnormal termination(abort)
 * Default action: terminate + core
 * generated when a process calls the abort function
 *
 *
 * #define SIGIOT		 6
 * Description: hardware fault
 * Default action: terminate + core
 *
 *
 * #define SIGBUS		 7
 * Description: hardware fault
 * Default action: terminate + core
 * usually generated this signal on certain types of memory faults
 *
 * #define SIGFPE		 8
 * Description: arithmetic exception
 * Default action: terminate + core
 * generated such as divide by 0, floating-point overflow, and so on.
 *
 * #define SIGKILL		 9
 * Description: termination
 * Default action: terminate
 * can NOT be ignored, can NOT be caught
 * generated when the process has executed an illegal hardware instruction.
 *
 *
 * #define SIGUSR1		10
 * Description: user-defined signal
 * Default action: terminate
 *
 *
 * #define SIGSEGV		11
 * Description: invalid memory reference
 * Default action: terminate + core
 * generated for a process that executes an invalid memory reference
 *
 *
 * #define SIGUSR2		12
 * Description: user-defined signal
 * Default action: terminate
 *
 *
 * #define SIGPIPE		13
 * Description: write to pipe with no readers
 * Default action: terminate
 * generated when a process writes to a pipe that has no reader
 * If we write to a pipeline but the reader has terminated, SIGPIPE is
 * generated
 *
 * #define SIGALRM		14
 * Description: timer expired(alarm)
 * Default action: terminate
 * generated when an alarm clock set by the process expires
 *
 *
 * #define SIGTERM		15
 * Description: termination
 * Default action: terminate
 *
 *
 * #define SIGSTKFLT	16
 * Description: coprocessor stack fault
 * Default action: terminate
 * kill command generates this signal
 *
 * #define SIGCHLD		17
 * Description: change in status of child
 * Default action: !!! ignore !!!
 * generated when a child process has terminated
 *
 *
 * #define SIGCONT		18
 * Description: continue stopped process
 * Default action: !!!continue/ignore !!!
 *
 *
 * #define SIGSTOP		19
 * Description: stop
 * Default action: stop process
 * can NOT be ignored, can NOT be caught
 *
 *
 *
 * #define SIGTSTP		20
 * Description: terminal stop character
 * Default action: stop process
 *
 * #define SIGTTIN		21
 * Description: background read from control tty
 * Default action: stop process
 *
 *
 * #define SIGTTOU		22
 * Description: background write to control tty
 * Default action: stop process
 *
 *
 * #define SIGURG		23
 * Description: urgent condition (sockets)
 * Default action: !!! ignore !!!
 * generated when out-of-band data arrives over a network connection
 *
 *
 * #define SIGXCPU		24
 * Description: CPU limit exceeded (setrlimit)
 * Default action: terminate or terminate + core
 *
 *
 * #define SIGXFSZ		25
 * Description: file size limit exceeded (setrlimit)
 * Default action: terminate or terminate + core
 *
 *
 * #define SIGVTALRM	26
 * Description: virtual time alarm (setitimer)
 * Default action: terminate
 *
 *
 * #define SIGPROF		27
 * Description: profiling time alarm (setitimer)
 * Default action: terminate
 *
 *
 * #define SIGWINCH	28
 * Description: terminal window size change
 * Default action: !!! ignore !!!
 *
 *
 * #define SIGIO		29
 * Description: indicata an asynchronous I/O event
 * Default action: terminate/ignore
 *
 *
 * #define SIGPOLL		SIGIO
 * Description: pollable event (poll)
 * Default action: terminate
 *
 *
 * #define SIGPWR		30
 * Description: power fail/restart
 * Default action: terminate/ignore
 *
 *
 * #define SIGSYS		31
 * Description: invalid system call
 * Default action: terminate + core
 */

#if 0
static char *signal_string[] = {
	"null",    "SIGHUP",  "SIGINT",    "SIGQUIT",
	"SIGILL",  "SIGTRAP",   "SIGABRT/SIGIOT",
	"SIGBUS",  "SIGFPE",    "SIGKILL",
	"SIGUSR1", "SIGSEGV",
	"SIGUSR2", "SIGPIPE",   "SIGALRM",
	"SIGTERM", "SIGSTKFLT", "SIGCHLD",
	"SIGCONT", "SIGSTOP",   "SIGTSTP",
	"SIGTTIN", "SIGTTOU",   "SIGURG",
	"SIGXCPU", "SIGXFSZ",   "SIGVTALRM",
	"SIGPROF", "SIGWINCH",  "SIGIO/SIGPOLL/SIGLOST",
	"SIGPWR",  "SIGSYS"
};
#endif

static void sig_handler(int signo);
static inline int valid_signal(int signo)
{
	return signo > 0 && signo < 32;
}

/*
Whenever a process terminates or stops, the SIGCHLD signal is sent to
the parent. By default, this signal is ignored, so the parent must catch
this signal if it wants to be notified whenever a child’s status changes.
The normal action in the signal-catching function is to call one of the
wait functions to fetch the child’s process ID and termination status.
*/
static void sig_child(void)
{
	pid_t pid;
	int stat;
	pid = wait(&stat);
	(void) pid;

	struct sigaction sa;
	sa.sa_handler = sig_handler;
	sa.sa_flags = 0;
	sigemptyset(&sa.sa_mask);
	sigaction(SIGCHLD, &sa, 0);
}

static void sig_handler(int signo)
{
	func_enter();
	if (valid_signal(signo))
		// sys_debug(1, "Got signal: %s", signal_string[signo]);
		sys_debug(1, "Got signal: %s", strsignal(signo));
	switch (signo) {
	case SIGPIPE: /* don't exit when socket closeed */
		break;
	case SIGINT:
	case SIGTERM:
	case SIGUSR1:
	case SIGSEGV:
		printf("Opps, got signal %d, process terminated!\n", signo);
		exit(0);
		break;
	case SIGCHLD:
		printf("Opps, got SIGCHLD signal\n");
		sig_child();
		break;
	default:
		printf("Opps, default got %d signal, process terminated!\n", signo );
		exit(0);
		break;
	}
	func_exit();
}

void setup_signal_handler()
{
	func_enter();
	struct sigaction sa;
#if 0
	struct sigaction {
		__sighandler_t sa_handler;
		unsigned long sa_flags;
#ifdef SA_RESTORER
		__sigrestore_t sa_restorer;
#endif
		sigset_t sa_mask;		/* mask last for extensibility */
	};
#endif
	sa.sa_handler = sig_handler;
	sa.sa_flags = 0;
	sigemptyset(&sa.sa_mask);

	/**
	 * typedef void (*sighandler_t)(int);
	 * sighandler_t signal(int signum, sighandler_t handler);
	 * 
	 * signal() sets the disposition if the signal signum to handler, which is either
	 * SIG_IGN, SIG_DEF, or the address of a paremeter-defined function ("signal handler")
	 *
	 * If the signal signum is delivered to the process, then one of the following happens:
	 *	- If the disposition is set to SIG_IGN, then the signal is ignored.
	 *	- If the disposition is set to SIG_DFL, then the default action associated with the signal
	 *	- If the disposition is set to a function, then first either the disposition is
	 *	  reset to SIG_DFL, or the signal is blocked, and then handler is called with argument signum
	 *
	 * int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
	 * The sigaction() system call is used to change the action taken by a process on receipt of a specific signal
	 *
	 * !The signals SIGKILL and SIGSTOP cannot be caught or ignored
	 */
	// CPU检测到某进程执行了非法指令。默认动作为终止进程并产生core文件
	sigaction(SIGILL,  &sa, 0);
	// 非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件 
	sigaction(SIGBUS,  &sa, 0);
	// 指示进程进行了无效内存访问。默认动作为终止进程并产生core文件
	sigaction(SIGSEGV, &sa, 0);
	// 无效的系统调用。默认动作为终止进程并产生core文件
	sigaction(SIGSYS,  &sa, 0);
	// 当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程
	sigaction(SIGHUP,  &sa, 0);
	// Broken pipe向一个没有读端的管道写数据。默认动作为终止进程
	sigaction(SIGPIPE, &sa, 0);
	// 当用户按下了< Ctrl+C>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止里程
	sigaction(SIGINT,  &sa, 0);
	// 用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程
	sigaction(SIGUSR1, &sa, 0);
	// 程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号。默认动作为终止进程
	sigaction(SIGTERM, &sa, 0);
	sigaction(SIGCHLD, &sa, 0);

	func_exit();
}
